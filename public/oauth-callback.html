<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Completing Sign In...</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #ffffff;
      color: #1f2937;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      text-align: center;
      max-width: 400px;
      width: 100%;
    }

    .icon {
      width: 64px;
      height: 64px;
      margin: 0 auto 24px;
    }

    .spinner {
      border: 4px solid #e5e7eb;
      border-top: 4px solid #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .success-icon {
      background: #10b981;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .success-icon svg {
      width: 40px;
      height: 40px;
      stroke: white;
      stroke-width: 3;
      fill: none;
    }

    .error-icon {
      background: #ef4444;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .error-icon svg {
      width: 40px;
      height: 40px;
      stroke: white;
      stroke-width: 3;
      fill: none;
    }

    h1 {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 12px;
      color: #111827;
    }

    p {
      font-size: 16px;
      color: #6b7280;
      line-height: 1.5;
    }

    .error-message {
      color: #dc2626;
      margin-top: 8px;
      font-size: 14px;
    }

    .countdown {
      margin-top: 16px;
      font-size: 14px;
      color: #9ca3af;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="loading-state">
      <div class="icon spinner"></div>
      <h1>Completing sign in...</h1>
      <p>Please wait while we finish setting up your account.</p>
    </div>

    <div id="success-state" style="display: none;">
      <div class="icon success-icon">
        <svg viewBox="0 0 24 24">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
      </div>
      <h1>Sign in successful!</h1>
      <p>You can now close this window.</p>
      <p class="countdown" id="success-countdown"></p>
    </div>

    <div id="error-state" style="display: none;">
      <div class="icon error-icon">
        <svg viewBox="0 0 24 24">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </div>
      <h1>Sign in failed</h1>
      <p id="error-message" class="error-message"></p>
      <p class="countdown" id="error-countdown"></p>
    </div>
  </div>

  <script>
    (function() {
      'use strict';

      // Parse URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const success = urlParams.get('success');
      const state = urlParams.get('state');
      const error = urlParams.get('error');

      // Determine worker API URL based on environment
      // Use window.location.origin for production (CloudFront proxies /api/* to worker)
      const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
      const workerBaseUrl = isLocalhost
        ? 'http://localhost:8787'
        : window.location.origin;

      // Detect if this window was opened as a popup
      // More reliable than checking window.opener (which can be null after cross-origin navigation)
      function isPopupWindow() {
        // Check if window has a name that matches our OAuth popup naming convention
        const hasOAuthWindowName = window.name && (
          window.name.includes('oauth') ||
          window.name.includes('_oauth') ||
          window.name === 'google_oauth' ||
          window.name === 'apple_oauth'
        );

        // Check if window was opened (opener might be null after cross-origin nav, but history.length will be 1)
        const hasShortHistory = window.history.length <= 2;

        // Check window features that indicate a popup
        const isSmallWindow = window.outerWidth < 700 && window.outerHeight < 800;

        // If we have an opener, definitely a popup
        if (window.opener) {
          return true;
        }

        // If window name matches our OAuth pattern, treat as popup
        if (hasOAuthWindowName) {
          return true;
        }

        // If it's a small window with short history, likely a popup
        if (isSmallWindow && hasShortHistory) {
          return true;
        }

        return false;
      }

      // Detect if running in standalone PWA mode (especially iOS)
      function isStandalonePWA() {
        // If we're in a popup window, we're NOT in standalone PWA mode
        // This is critical because display-mode: standalone can match in popup windows
        if (isPopupWindow()) {
          return false;
        }

        // iOS Safari standalone mode
        const isIOSStandalone = ('standalone' in window.navigator) && window.navigator.standalone === true;

        // Standard PWA display mode (Android, desktop)
        const isDisplayStandalone = window.matchMedia('(display-mode: standalone)').matches;
        const isDisplayMinimalUI = window.matchMedia('(display-mode: minimal-ui)').matches;

        return isIOSStandalone || isDisplayStandalone || isDisplayMinimalUI;
      }

      // Detect iOS platform
      function isIOS() {
        const userAgent = window.navigator.userAgent.toLowerCase();
        return /iphone|ipad|ipod/.test(userAgent);
      }

      const isPopup = isPopupWindow();
      const isInStandalonePWA = isStandalonePWA();
      const isIOSDevice = isIOS();

      console.info('[OAuth Callback] Window detection:', {
        isPopup,
        isInStandalonePWA,
        isIOSDevice,
        hasOpener: !!window.opener,
        windowName: window.name,
        historyLength: window.history.length,
        windowSize: `${window.outerWidth}x${window.outerHeight}`,
      });

      // Show error state
      async function showError(message) {
        document.getElementById('loading-state').style.display = 'none';
        document.getElementById('success-state').style.display = 'none';
        document.getElementById('error-state').style.display = 'block';
        document.getElementById('error-message').textContent = message;

        // Broadcast error via oauth-handshake (await to ensure it completes before redirect)
        await broadcastOAuthState(state, false, message);

        // For standalone PWA (especially iOS): redirect back to app
        if (isInStandalonePWA) {
          let countdown = 2;
          const countdownEl = document.getElementById('error-countdown');
          countdownEl.textContent = `Redirecting to app in ${countdown} seconds...`;

          const interval = setInterval(function() {
            countdown--;
            if (countdown > 0) {
              countdownEl.textContent = `Redirecting to app in ${countdown} seconds...`;
            } else {
              clearInterval(interval);
              // Redirect back to main app
              window.location.href = '/?oauth_complete=true';
            }
          }, 1000);
        } else {
          // For popup flow: try to close window
          let countdown = 3;
          const countdownEl = document.getElementById('error-countdown');
          countdownEl.textContent = `Closing in ${countdown} seconds...`;

          const interval = setInterval(function() {
            countdown--;
            if (countdown > 0) {
              countdownEl.textContent = `Closing in ${countdown} seconds...`;
            } else {
              clearInterval(interval);
              // Try to close the window - this works for popups even if opener is null
              // (window.opener can be null after cross-origin navigation during OAuth)
              try {
                window.close();
              } catch (e) {
                console.warn('[OAuth Callback] window.close() failed:', e);
              }
              // If close didn't work, show manual close message after a brief delay
              setTimeout(function() {
                if (!window.closed) {
                  countdownEl.textContent = 'Please close this window manually.';
                }
              }, 100);
            }
          }, 1000);
        }
      }

      // Show success state
      async function showSuccess() {
        document.getElementById('loading-state').style.display = 'none';
        document.getElementById('error-state').style.display = 'none';
        document.getElementById('success-state').style.display = 'block';

        // Broadcast success via oauth-handshake (await to ensure fetch completes before redirect)
        await broadcastOAuthState(state, true);

        // For standalone PWA (especially iOS): redirect back to app immediately
        if (isInStandalonePWA) {
          const countdownEl = document.getElementById('success-countdown');
          countdownEl.textContent = 'Redirecting to app...';

          // Small delay to show success state, then redirect
          setTimeout(function() {
            window.location.href = '/?oauth_complete=true';
          }, 500);
        } else {
          // For popup flow: try to close window
          let countdown = 1;
          const countdownEl = document.getElementById('success-countdown');
          countdownEl.textContent = `Closing in ${countdown} second...`;

          setTimeout(function() {
            // Try to close the window - this works for popups even if opener is null
            // (window.opener can be null after cross-origin navigation during OAuth)
            try {
              window.close();
            } catch (e) {
              console.warn('[OAuth Callback] window.close() failed:', e);
            }
            // If close didn't work, show manual close message after a brief delay
            setTimeout(function() {
              if (!window.closed) {
                countdownEl.textContent = 'Please close this window manually.';
              }
            }, 100);
          }, 1000);
        }
      }

      // Broadcast OAuth state using the oauth-handshake protocol
      // This now fetches the auth result from the worker and stores it in localStorage
      // before redirecting, which is critical for PWA standalone mode
      async function broadcastOAuthState(state, success, errorMsg) {
        if (!state) return;

        let result = null;

        // If successful, fetch the auth result from the worker
        if (success) {
          try {
            console.info('[OAuth Callback] Fetching auth result from worker', {
              state: state.substring(0, 8) + '...',
              workerUrl: workerBaseUrl,
            });

            const response = await fetch(`${workerBaseUrl}/api/auth/oauth/result?state=${encodeURIComponent(state)}`, {
              method: 'GET',
              headers: {
                Accept: 'application/json',
              },
              credentials: 'include',
            });

            const data = await response.json().catch(() => ({}));

            if (response.ok && data.status === 'success' && data.authData) {
              console.info('[OAuth Callback] Auth result fetched successfully');
              result = {
                status: 'success',
                state: state,
                authData: data.authData
              };
            } else {
              console.warn('[OAuth Callback] Failed to fetch auth result', {
                status: response.status,
                data: data
              });
              const message = (data && data.message) || 'Failed to complete OAuth.';
              result = {
                status: 'error',
                state: state,
                error: message
              };
            }
          } catch (error) {
            console.error('[OAuth Callback] Error fetching auth result:', error);
            result = {
              status: 'error',
              state: state,
              error: error instanceof Error ? error.message : 'Network error while completing OAuth.'
            };
          }
        } else {
          result = {
            status: 'error',
            state: state,
            error: errorMsg || 'OAuth failed'
          };
        }

        // Store the result in localStorage with the correct key
        // This is critical for PWA mode where the redirect causes a new page load
        try {
          localStorage.setItem('oauth_handshake_result', JSON.stringify(result));
          console.info('[OAuth Callback] Stored result in localStorage');
        } catch (e) {
          console.warn('[OAuth Callback] Failed to store result in localStorage:', e);
        }

        const payload = {
          type: 'oauth_handshake',
          state: state,
          success: success,
          error: errorMsg || null,
          timestamp: Date.now(),
          result: result
        };

        // Try BroadcastChannel
        try {
          if (typeof BroadcastChannel !== 'undefined') {
            const channel = new BroadcastChannel('oauth-handshake');
            channel.postMessage(payload);
            channel.close();
          }
        } catch (e) {
          console.warn('[OAuth Callback] BroadcastChannel failed:', e);
        }

        // Try postMessage to opener
        if (window.opener && typeof window.opener.postMessage === 'function') {
          try {
            window.opener.postMessage(payload, window.location.origin);
          } catch (e) {
            console.warn('[OAuth Callback] postMessage to opener failed:', e);
          }
        }

        // Try localStorage for state (legacy)
        try {
          localStorage.setItem('oauth_handshake_state', JSON.stringify(payload));
        } catch (e) {
          console.warn('[OAuth Callback] localStorage failed:', e);
        }
      }

      // Handle OAuth callback
      async function handleCallback() {
        // Validate state parameter
        if (!state) {
          await showError('Invalid callback: missing state parameter.');
          return;
        }

        // Check if this state has already been processed
        // This prevents duplicate processing if the page is reloaded or navigated to again
        const processedStatesKey = 'oauth_processed_states';
        try {
          const processedStatesStr = localStorage.getItem(processedStatesKey);
          const processedStates = processedStatesStr ? JSON.parse(processedStatesStr) : {};

          if (processedStates[state]) {
            console.info('[OAuth Callback] State already processed, redirecting to app', {
              state: state.substring(0, 8) + '...',
              processedAt: new Date(processedStates[state]).toISOString(),
            });

            // Redirect to app immediately to avoid re-processing
            if (isInStandalonePWA) {
              window.location.href = '/?oauth_complete=true';
            } else {
              await showError('This sign-in link has already been used. You can close this window.');
            }
            return;
          }

          // Mark this state as processed immediately
          processedStates[state] = Date.now();

          // Keep only the last 10 states to prevent localStorage bloat
          const stateKeys = Object.keys(processedStates);
          if (stateKeys.length > 10) {
            const sortedKeys = stateKeys.sort((a, b) => processedStates[b] - processedStates[a]);
            const keysToKeep = sortedKeys.slice(0, 10);
            const newProcessedStates = {};
            keysToKeep.forEach(key => {
              newProcessedStates[key] = processedStates[key];
            });
            localStorage.setItem(processedStatesKey, JSON.stringify(newProcessedStates));
          } else {
            localStorage.setItem(processedStatesKey, JSON.stringify(processedStates));
          }
        } catch (e) {
          console.warn('[OAuth Callback] Failed to check/mark processed state:', e);
          // Continue anyway - better to potentially duplicate than to break login
        }

        // Check for error from worker redirect
        if (success === 'false' || error) {
          const message = error ? decodeURIComponent(error) : 'Authentication failed';
          await showError(message);
          return;
        }

        // Success case - worker has already processed the callback
        if (success === 'true') {
          await showSuccess();
          return;
        }

        // Fallback: no success parameter, show error
        await showError('Invalid callback response from server.');
      }

      // Start the callback process
      handleCallback();
    })();
  </script>
</body>
</html>
